"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiscordChannel = void 0;
const MenuVisual_1 = require("./visuals/MenuVisual");
const MessageVisual_1 = require("./visuals/MessageVisual");
class DiscordChannel {
    constructor(channel) {
        this.messages = [];
        this.id = channel.id;
        this.channel = channel;
    }
    /**
     * Store all messages sent within this channel
     * @param message Message to store
     */
    storeMessages(message) {
        if (Array.isArray(message)) {
            message.forEach(m => this.messages.push(m));
        }
        else {
            this.messages.push(message);
        }
    }
    /**
     * Set up a menu embed on a message response
     * @param menuEmbed What menu to set up
     * @param messageResponse The message to set the menu up on
     */
    trySetupPagination(menuEmbed, messageResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Array.isArray(messageResponse) && messageResponse.length > 1) {
                throw new Error('Pagination with multiple messages sent with one call. Disabling message splitting may resolve this.');
            }
            const toPaginate = Array.isArray(messageResponse) ? messageResponse[0] : messageResponse;
            yield menuEmbed.setUpPagination(toPaginate);
        });
    }
    sendMenuVisual(visual) {
        return __awaiter(this, void 0, void 0, function* () {
            let options = {};
            if (visual.options) {
                options = Object.assign({}, visual.options);
            }
            options.embed = visual.menu.getEmbedOfPage(0);
            const sent = yield this.channel.send('', options);
            if (visual.menu.canPaginate()) {
                yield this.trySetupPagination(visual.menu, sent);
            }
            return sent;
        });
    }
    sendMessageVisual(visual) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Object.assign({}, visual.options);
            return this.channel.send(visual.text, options);
        });
    }
    send(visual) {
        return __awaiter(this, void 0, void 0, function* () {
            if (visual instanceof MenuVisual_1.MenuVisual) {
                const sent = yield this.sendMenuVisual(visual);
                this.storeMessages(sent);
                return sent;
            }
            else if (visual instanceof MessageVisual_1.MessageVisual) {
                const sent = yield this.sendMessageVisual(visual);
                this.storeMessages(sent);
                return sent;
            }
            else {
                throw new TypeError('Invalid visual format, must be MenuVisual or MessageVisual');
            }
        });
    }
}
exports.DiscordChannel = DiscordChannel;
